<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evaluación de riesgos</title>
    <script src="https://cdn.jsdelivr.net/npm/gaugeJS/dist/gauge.min.js"></script>
    <link href="../estilos/estiloSituacionFinanciera.css" rel="stylesheet">
    <!-- <link href="css/st-gobCorpo.css" rel="stylesheet"> -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Abel&family=Barlow+Condensed:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Courgette&family=Gupter:wght@400;500;700&family=PT+Sans+Narrow:wght@400;700&family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&display=swap" rel="stylesheet">
  
  
    <style>
        table {
            width: 95%;
            border-collapse: collapse;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f4f4f4;
        }

        /* Subrayar la última fila */
        tr:last-child td {
            border-bottom: 1px solid #ddd; /* Puedes ajustar el grosor y el color */
        }

        .checkbox-matriz {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 3 columnas */
            gap: 5px;
        }

        .checkbox-item {
          padding: 5px;
        }

        .question-cell {
            text-align: left;
        }
        .option-input {
            margin-right: 5px;
        }
    </style>
  </head>

  <body class="menu-a-page mercado">
    <div class="survey-container">
      <section class="main">
        <section class="gobCorpo">
          <div class="header-container">
            <div class="header-center">
              <div id="nombreEmpresa" class="company-name"></div>
              <div id="nombreUsuario" class="user-name"></div>
            </div>
            <div class="nav-iconsxx">
              <h4> C - Calidad del manejo de los Riesgos de Mercado</h4>
            </div>
            <div class="nav-iconsxx">
              <h5> Autoevaluación</h5>
            </div>
          </div>
    <hr>
    
    <!-- <form id="formulario"> -->
      <form id="surveyForm" action="/procesar" method="POST">
      <!-- <form id="surveyForm"> -->
    
      <div class="salida">
        <a href="javascript:void(0);" onclick="window.history.back();">
          <img src="../img/contenido (1).png" alt="Logo Izquierda" class="logo left">
        </a>
        <button type="button" id="boton-salir">Salir</button>
      </div>
      <div>
        <p>Seleccione la opción que mejor refleje el grado de cumplimiento de la situación descripta en su organización, donde 'Muy efectivo' indica coincidencia o certeza total, y 'No efectivo' refleja la ausencia de aplicación.</p>
      </div>
      <p id="tip">Puede utilizar la tecla TAB o Mayus+TAB (->| y |<-) para avanzar/retroceder en las filas y las teclas de dirección ( <  > ) para seleccionar la opción</p>
      <div id="overlay">
        <div id="ventanaSalida">
          <!-- <div class="confirm-modal" id="confirm-modal">-->
          <div class="confirm-box">
            <p>La información registrada hasta el momento quedará almacenada. <br> Si sale de la aplicación, podrá
              completar posteriormente los items faltantes.
              <br>
            </p>Confirme si desea 'Salir' de la aplicación o 'Continuar' con el registro de datos.</p>
            <button id="confirm-yes">Salir</button>
            <button id="confirm-no">Continuar</button><br>
          </div>
        </div>
      </div>

  <!-- <form id="checklist-form" action="/procesar" method="POST"> -->
<table>
  <thead>
    <tr>
      <th>#</th>
      <th class="pregunta-col">Situación</th>
      <th class="respuesta-col">No efectivo</th>
      <th class="respuesta-col">Poco efectivo</th>
      <th class="respuesta-col">Efectivo</th>
      <th class="respuesta-col">Muy efectivo</th>
    </tr>
  </thead>
  <tbody id="questionsTableBody">
      <!-- Las preguntas se agregarán aquí dinámicamente -->
  </tbody>
</table>

<br>

<h3>Factores que se han tenido en cuenta en la creación de la estrategia, para el corto y mediano plazo:</h3>
  <p>(Marque todos los que correspondan)</p>
  <p id="tip">Puede utilizar la tecla TAB o Mayus+TAB (->| y |<-) para avanzar/retroceder entre factores y la barra espaciadora para seleccionarlos</p>

  <!-- <form id="checklist-form" action="/procesar" method="POST"> -->
    <div class="checkbox-matriz" id="checkbox-matriz">
      <!-- Los checkboxes se generarán dinámicamente aquí -->
    </div>

  <div class="centrado-flex">
    <button type="submit" id="boton-enviar">Enviar</button>
    </div>
    
    <div class="centrado-flex">
    <button type="button" id="boton-borrar" onclick="limpiarSelecciones()">Limpiar selecciones</button>
    </div>

  <!-- <button type="submit">Enviar</button>
  <button type="submit" id="boton-enviar" onclick="resumenGeneral()">Enviar</button> -->

</form>

<div id="miAlerta" class="alerta-oculto">
  <div class="alerta-contenido">
    <div class="alerta-cabecera">
      <span>Resumen de la sección</span>
    </div>
    <div class="alerta-cuerpo">
      <p>Puntaje máximo posible: <span id="maximo"></span></p>
      <p>Calificación obtenida: <span id="calificacion"></span></p>
      <p>Porcentual: <span id="porcentual"></span></p>

    <div class="gauge-container">
      <canvas id="gaugeChart";></canvas>
    </div>

      <button id="continuar" onclick="continuar()">Continuar</button>
    </div>
  </div>
</div>


<script>
  const capitulo = "C";
  const seccion = 1;
  const responses = [];
  let puntajesIndividuales = [];
  let valores = 0;
  let precios = [];
  let respuestas = [];
  let porcientoFormateado = 0;
  let total = 0;
  let isExiting = false;
  let faltantes = false;
  let cantidadSeleccionados = 0;

  precios = filtrarPrecios();

      // Función para construir la tabla de preguntas
  function buildForm(questions) {
      const tableBody = document.getElementById('questionsTableBody');
      questions.forEach(question => {
          const row = document.createElement('tr');

      // Numero de pregunta
      const numeroCell = document.createElement('td');
      numeroCell.classList.add('question-cell');
      numeroCell.textContent = question.Numero;
      row.appendChild(numeroCell);

      // Columna de la pregunta
      const questionCell = document.createElement('td');
      questionCell.classList.add('question-cell');
      questionCell.textContent = question.Descrip;
      row.appendChild(questionCell);
              
      // Opciones
      for (let i = 1; i <= 4; i++) {
          const optionCell = document.createElement('td');
          
          const optionInput = document.createElement('input');
          optionInput.type = 'radio';
          optionInput.name = `question_${question.id}`;
          optionInput.value = i;
          optionInput.classList.add('option-input');
          optionInput.id = `q${question.id}_o${i}`;
          
          // Añadir el input directamente en la celda
          optionCell.appendChild(optionInput);
          row.appendChild(optionCell);
      }
      tableBody.appendChild(row);
  });
  }

  // Función para obtener las preguntas del servidor
  function cargarPrimerasPreguntas() {
    let url = '/preguntas';

    // Agregar parámetros a la URL si existen
    let capitulo = "C";
    let seccion = 1;
    if (capitulo || seccion) {
        url += `?${capitulo ? `capitulo=${encodeURIComponent(capitulo)}` : ''}${capitulo && seccion ? '&' : ''}${seccion ? `seccion=${encodeURIComponent(seccion)}` : ''}`;
    }

    fetch(url)
        .then(response => response.json())
        .then(data => buildForm(data))
        .catch(error => console.error('Error al cargar las preguntas:', error));
  }

  // Cargar las preguntas cuando la página se cargue
  document.addEventListener('DOMContentLoaded', cargarPrimerasPreguntas);

  // Función para manejar la recopilación de respuestas
  function obtenerRespuestas() {
    const responses = [];
    let filasSinSeleccion = [];  // Array para guardar las filas sin seleccionar

    // Obtener respuestas de los radio buttons
    const questionsRows = document.querySelectorAll('#questionsTableBody tr');
    questionsRows.forEach((row, index) => {
        const selectedOption = row.querySelector('input[type="radio"]:checked');
        if (selectedOption) {
            responses.push(parseInt(selectedOption.value));  // Agregar el valor seleccionado
        } else {
            filasSinSeleccion.push(index + 1);  // Guardar el número de fila si no se ha seleccionado nada
        }
    });

      // Si hay filas sin seleccionar, mostrar la alerta y salir de la función
    faltantes = false;
    if (filasSinSeleccion.length > 0) {
      alert(`Debe seleccionar una opción en las siguientes filas: ${filasSinSeleccion.join(', ')}`);
      faltantes = true;
      // return null;  // Detener la ejecución si faltan selecciones
    }

    // Obtener valores seleccionados de los checkboxes
    const checkboxes = document.querySelectorAll('input[name="registro"]:checked');
    const checkboxValues = Array.from(checkboxes).map(checkbox => parseInt(checkbox.value));
    responses.push(checkboxValues); // Añadir el subarreglo de checkboxes seleccionados
    // Sumar la cantidad de checkboxes seleccionados
    cantidadSeleccionados = checkboxValues.length;
    // Mostrar la cantidad seleccionada en la consola
    console.log(`Cantidad de checkboxes seleccionados: ${cantidadSeleccionados}`);

    console.log(responses); // Aquí se muestra el vector en la consola
    return responses;
  }

// Definir la función loadQuestions correctamente
  async function loadCheckbox() {
    let url = '/preguntas';

    // Agregar parámetros a la URL si existen
    let capitulo = "C";
    let seccion = 2;
    if (capitulo || seccion) {
      url += `?${capitulo ? `capitulo=${encodeURIComponent(capitulo)}` : ''}${capitulo && seccion ? '&' : ''}${seccion ? `seccion=${encodeURIComponent(seccion)}` : ''}`;
    }

      // Retornar el fetch para manejarlo como una Promise
    try {
      const response = await fetch(url);
      const data = await response.json();
      return data; // Devolver los datos parseados
    } catch (error) {
      console.error('Error al cargar las preguntas:', error);
      throw error;
      }
    }

    // Función para cargar los registros desde la API y generar los checkboxes
  async function cargarRegistros() {
    try {
      const response = await loadCheckbox();
      const registros = response;
      const matriz = document.getElementById('checkbox-matriz');
      
      registros.forEach((registro, index) => {
        const checkboxDiv = document.createElement('div');
        checkboxDiv.className = 'checkbox-item';
        checkboxDiv.innerHTML = `
          <label>
            <input type="checkbox" name="registro" value="${index}">
            ${registro.Descrip} <!-- Ajusta según tu base de datos -->
          </label>
        `;
        matriz.appendChild(checkboxDiv);
      });
    } catch (error) {
      console.error('Error al cargar los registros:', error);
    }
  }
    cargarRegistros(); // Cargar los registros de checkbox 

async function obtenerListaPreciosB() {
  try {
    const response = await fetch('/leeListaPrecios'); // Usa la URL correcta para tu API
    if (response.ok) {
      const listaPrecios = await response.json();
      return listaPrecios;
    } else {
      console.error('Error en la respuesta:', response.status, response.statusText);
      return null;
    }
  } catch (error) {
    console.error('Error en la solicitud:', error);
    return null;
  }
}

async function filtrarPrecios() {
  try {
    // Llamar a la función para obtener los precios
    const listaPreciosB = await obtenerListaPreciosB();
    precios = listaPreciosB.filter (seccion => seccion.seccion == 1 && seccion.capitulo == "C");
    // Usar reduce para sumar el campo "maximo" de los registros filtrados
    maximo = precios.reduce((maximo, registro) => {
      return maximo + Number(registro.maximo);
    }, 0);  // El segundo parámetro (0) es el valor inicial del acumulador
    console.log('Suma total de maximos:', maximo);
    //  le suma 290 puntos por seleccionar los 29 checkboxes..
    maximo += 290;
    console.log ('suma con checkboxes:' , maximo);
  } catch (error) {
    console.error('Error mostrando los precios:', error);
  }
}

function valorizarRadios() {
  // Limitar a las primeras 14 respuestas
  const respuestasLimitadas = respuestas.slice(0, 14);
  respuestasLimitadas.forEach((respuesta, index) => {
    if (respuesta >= 1 && respuesta <= 4) {
      // Accede al precio correspondiente (restamos 1 para ajustar el índice)
      // let fila = precios[index];
      // let unitario = fila.precio[respuesta-1];
      let precioCorrespondiente = precios[index].precio[respuesta - 1]; 
      total += Number(precioCorrespondiente); // Sumar el precio al total
    }
  });

  console.log('Total valorizado:', total); // Muestra el total en la consola

  total += cantidadSeleccionados * 10;
  return total; // Devuelve el total si lo necesitas
}

// Prevenir el comportamiento por defecto al presionar Enter en el formulario
document.addEventListener('DOMContentLoaded', function () {
  document.getElementById('surveyForm').addEventListener('keypress', function (event) {
    // Si el usuario presiona Enter (keyCode 13) dentro del formulario
    if (event.key === 'Enter') {
      event.preventDefault(); // Evitar el envío del formulario
    }
  });
});

  // Manejar el envío del formulario
document
  .getElementById('surveyForm')
  .addEventListener('submit', function(event) {
    if (isExiting) { // Verifica si está para salir y evita la validación en ese caso
      isExiting = false;  // Reinicia el indicador  para futuras operaciones
      return;   // Omite la validación cuando se está intentando salir
    }
  event.preventDefault(); // Evita el envío estándar

  respuestas = obtenerRespuestas();
  // Si las respuestas son válidas (no hay filas sin seleccionar), procede

  if (!faltantes) {

      valores = valorizarRadios(precios);

      porcientoFormateado = ((valores / maximo) * 100).toFixed(2);

      mostrarMiAlerta(maximo, valores, porcientoFormateado);
      console.log("Formulario completo. Procesando envío...");
    } else {
      // No hacer nada, esperar a que el usuario complete las respuestas
      console.log("Faltan respuestas. El formulario no se enviará hasta que se completen todas las opciones.");
  }

  const checkboxes = document.querySelectorAll('input[name="registro"]');
  const seleccionados = Array.from(checkboxes).map(checkbox => checkbox.checked ? 1 : 0);

});

  const apellidouser = localStorage.getItem("apellido");
  const nombreUser = localStorage.getItem("nombre");
  const apenom = nombreUser + ' ' + apellidouser;
  const empresa = localStorage.getItem("empresa");
  document.getElementById("nombreEmpresa").textContent = empresa;
  document.getElementById("nombreUsuario").textContent = apenom;

  document.getElementById('surveyForm').addEventListener('submit', function (event) {
    event.preventDefault();
  });
  const botonSalida = document.getElementById('boton-salir');
  const ventanaSale = document.getElementById('ventanaSalida');
  const botonYes = document.getElementById('confirm-yes');
  const botonNou = document.getElementById('confirm-no');

  botonSalida.addEventListener('click', () => { // Agrega un evento al botón para mostrar la ventana
    let isExiting = true;
    ventanaSale.style.display = 'block';
    document.getElementById('overlay').style.display = 'block';
  });

  botonNou.addEventListener('click', () => {  // Agrega un evento para el botón NO
    isExiting = true;
    console.log('dijo que NO')
    ventanaSale.style.display = 'none';
    document.getElementById('overlay').style.display = 'none'; // Continúa con la operación original de la página
  });

  botonYes.addEventListener('click', () => {  // Agrega un evento para el botón SI
    console.log('dijo que SI')
    isExiting = true;
    window.location.href = '../../index.html';
  });

function resumenGeneral() {
  window.location.href =
    JSON.parse(localStorage.getItem("idioma")) == 1
      ? "resumenGeneral3.html"
      : "resumenGeneral3-en.html";
}
  
function limpiarSelecciones() {
  const radios = document.querySelectorAll('input[type="radio"]');
  const checkboxes = document.querySelectorAll('input[type="checkbox"]');
  
  radios.forEach(radio => radio.checked = false);
  checkboxes.forEach(checkbox => checkbox.checked = false);
}

function mostrarMiAlerta(maximo, valores, porcientoFormateado) {

  document.getElementById('miAlerta').style.display = 'block';

  const target = document.getElementById('gaugeChart'); // your canvas element
  const gauge = new Gauge(target).setOptions(opts); // create gauge!
  gauge.maxValue = 100; // set max gauge value
  gauge.setMinValue(0);  // Prefer setter over gauge.minValue = 0
  gauge.animationSpeed = 32; // set animation speed (32 is default value)
  gauge.set(porcientoFormateado); // set actual value

  // Actualizar los contenidos
  document.getElementById('maximo').textContent = maximo;
  document.getElementById('calificacion').textContent = valores;
  document.getElementById('porcentual').innerHTML = '<strong>' + porcientoFormateado + '%<strong>';
}

function cerrarAlerta() {
  document.getElementById("miAlerta").style.display = "none";
}

function continuar() {
  cerrarAlerta();  // Opcional, depende de si quieres cerrar la alerta antes de cambiar la página

  grabarResultados2(respuestas);

  actualizaCapitulos(capitulo, maximo, valores, porcientoFormateado);
  localStorage.setItem("porciento-C", porcientoFormateado);
  window.location.href = "resumenGeneral3.html";
}

async function grabarResultados2(respuestas) {

const score = valores;
const respuesta = respuestas;
const porcentaje = porcientoFormateado;

const body = {
  capitulo,
  seccion,
  maximo, 
  score,
  porcentaje,
  respuesta
};

try {
  const response = await fetch("/insertar2", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
    credentials: "include",
  });

  const result = await response.json();
  if (result.success) {
    console.log("no hay error");
  } else {
    throw new Error(result.error || "Error desconocido ins 2");
  }
} catch (error) {
  console.log("Error:", error);
  alert("estamos en el error (ins 2): " + error.message);
  throw error; // Rechaza la promesa en caso de error
}
}


function actualizaCapitulos(capitulo, maximo, score, porcentaje) {
  fetch("/total-Capitulo", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ capitulo, maximo, score, porcentaje }),
  })
    .then((response) => {
      if (!response.ok) {
        throw new Error("Error en la actualización");
      }
      return response.text();
    })
    .then((data) => {
      // alert("Registro actualizado correctamente");
      console.log(data);
    })
    .catch((error) => {
      console.error(error);
    });
}

// Armar velocimetro ::::::::::::::::::::::::::::::::::::::
const opts = {
  angle: -0.3,
// The span of the gauge arc
  lineWidth: 0.2, // The line thickness
  radiusScale: 0.8, // Relative radius
  pointer: {
      length: 0.6, // // Relative to gauge radius
      strokeWidth: 0.035, // The thickness
      color: '#000000' // Fill color
  },
  limitMax: false,     // If false, max value increases automatically if value > maxValue
  limitMin: false,     // If true, the min value of the gauge will be fixed
  colorStart: '#6F6EA0',   // Colors
  colorStop: '#C0C0DB',    // just experiment with them
  strokeColor: '#EEEEEE',  // to see which ones work best for you
  generateGradient: true,
  highDpiSupport: true,     // High resolution support

  // Custom segment colors
  staticZones: [
     {strokeStyle: "red", min: 0, max: 50}, // Red from 0 to 25
     {strokeStyle: "orange", min: 50, max: 70}, // Red from 0 to 25
     {strokeStyle: "green", min: 70, max: 90}, // Yellow from 50 to 75
     {strokeStyle: "blue", min: 90, max: 100}  // Blue from 75 to 100
  ],

  staticLabels: {
      font: "15px sans-serif",  // Specifies font
      labels: [0, 50, 70, 90, 100],  // Print labels at these values
      color: "#000000",  // Optional: Label text color
      fractionDigits: 0  // Optional: Numerical precision. 0=round off.
  },
};

</script>

</html>